# action.yml
name: "Code Literal Sentinel"
description: "Varredura agressiva de literais hardcoded para indexa√ß√£o e an√°lise posterior por IA."
author: "Ricardo Malnati"

branding:
  icon: "eye"
  color: "orange"

inputs:
  token:
    description: "GitHub token (ex.: secrets.GITHUB_TOKEN) para ler diffs."
    required: true
  file_extensions:
    description: "Regex de extens√µes para varrer (Ex: ts|js|java|py)."
    required: false
    default: "ts|js|jsx|tsx|java|py|go|cs|php|sh|json|yaml|yml"
  exclude_patterns:
    description: "Regex de caminhos para ignorar completamente (Ex: node_modules|dist)."
    required: false
    default: "node_modules|dist|build|.git"
  output_file:
    description: "Caminho onde o √≠ndice bruto (arquivo f√≠sico) ser√° salvo."
    required: false
    default: "literals-index.txt"

outputs:
  result_json:
    description: "JSON contendo diagn√≥stico, contagens e orienta√ß√µes."
    value: ${{ steps.generate_output.outputs.json_payload }}
  index_path:
    description: "Caminho do arquivo f√≠sico gerado com os literais encontrados."
    value: ${{ steps.scan.outputs.file_path }}

runs:
  using: "composite"
  steps:
    # ------------------------------------------------------------------
    # STEP 0: DIAGN√ìSTICO DE INPUTS E AMBIENTE
    # ------------------------------------------------------------------
    - id: debug_inputs
      shell: bash
      env:
        EXTS: ${{ inputs.file_extensions }}
        EXCL: ${{ inputs.exclude_patterns }}
        OUT: ${{ inputs.output_file }}
      run: |
        echo "::group::üîç Step 0: Sentinel Configuration"
        echo "---------------------------------------------------------------"
        echo "üëÅÔ∏è  Code Literal Sentinel (Aggressive Mode)"
        echo "---------------------------------------------------------------"
        echo "üéØ Objetivo: Mapear TODOS os literais para an√°lise de IA."
        echo ""
        echo "‚öôÔ∏è  Par√¢metros de Busca:"
        echo "    - Extens√µes Alvo: .($EXTS)"
        echo "    - Exclus√µes:      $EXCL"
        echo "    - Arquivo Sa√≠da:  $OUT"
        echo "---------------------------------------------------------------"
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 0.5: VERIFICA√á√ÉO DE PERMISS√ïES
    # ------------------------------------------------------------------
    - id: debug_perms
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
        PR: ${{ github.event.pull_request.number }}
      run: |
        echo "::group::üîê Step 0.5: Permission Check"
        
        URL="https://api.github.com/repos/$REPO/pulls/$PR/files"
        echo "üì° Testando acesso de leitura (contents: read)..."
        
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN" "$URL")
        
        if [ "$HTTP_CODE" == "200" ]; then
           echo "   ‚úÖ Status 200 OK - Permiss√£o confirmada."
        else
           echo "   ‚õî Status $HTTP_CODE - Falha ao ler arquivos."
           echo "      A√ß√£o Requerida: Adicione 'contents: read' ao workflow."
           exit 1
        fi
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 1: SCAN AGRESSIVO (Grep Puro)
    # ------------------------------------------------------------------
    - id: scan
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        BASE_SHA: ${{ github.event.pull_request.base.sha }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        EXTS: ${{ inputs.file_extensions }}
        EXCLUDE: ${{ inputs.exclude_patterns }}
        OUT_FILE: ${{ inputs.output_file }}
      run: |
        set -euo pipefail
        
        echo "üîé Iniciando varredura profunda..."
        
        # 1. Listar arquivos modificados na PR
        # diff-filter=ACMRTUXB ignora arquivos deletados
        FILES=$(git diff --name-only --diff-filter=ACMRTUXB "$BASE_SHA" "$HEAD_SHA" \
          | grep -E "\.($EXTS)$" \
          | grep -vE "$EXCLUDE" || true)

        if [ -z "$FILES" ]; then
          echo "‚ö™ Nenhum arquivo eleg√≠vel modificado."
          echo "NO_FILES" > /tmp/scan_status
          exit 0
        fi

        # 2. Executar Grep Agressivo
        # Regex captura qualquer coisa entre aspas simples ou duplas com mais de 2 chars
        PATTERN="\"[^\"]{2,}\"|'[^']{2,}'"
        
        # Salva o resultado bruto no arquivo tempor√°rio
        # Formato: arquivo:linha:conteudo
        echo "$FILES" | xargs -r grep -HnE "$PATTERN" > /tmp/raw_findings.txt || true

        # Verifica se o arquivo tem conte√∫do
        if [ -s /tmp/raw_findings.txt ]; then
           echo "‚ö†Ô∏è Literais encontrados. Gerando √≠ndice..."
           cp /tmp/raw_findings.txt "./$OUT_FILE"
           echo "FOUND" > /tmp/scan_status
           
           # Conta linhas para m√©tricas
           COUNT=$(wc -l < /tmp/raw_findings.txt)
           echo "$COUNT" > /tmp/scan_count
        else
           echo "‚úÖ Nenhum literal detectado pelos padr√µes."
           echo "CLEAN" > /tmp/scan_status
           echo "0" > /tmp/scan_count
        fi
        
        echo "file_path=./$OUT_FILE" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 2: GERAR JSON DE DIAGN√ìSTICO (GITHUB_OUTPUT)
    # ------------------------------------------------------------------
    - id: generate_output
      shell: bash
      env:
        OUT_FILE: ${{ inputs.output_file }}
      run: |
        set -euo pipefail
        
        STATUS=$(cat /tmp/scan_status)
        COUNT="0"
        if [ -f /tmp/scan_count ]; then
           COUNT=$(cat /tmp/scan_count)
        fi

        # Constru√ß√£o do JSON usando jq para garantir formato v√°lido
        # Define mensagens de guidance baseadas no status
        
        if [ "$STATUS" == "FOUND" ]; then
           MSG="Literais detectados."
           GUIDE="O arquivo de √≠ndice cont√©m $COUNT ocorr√™ncias. Envie o arquivo '$OUT_FILE' para o agente de IA para filtragem contextual."
           COLOR="#dbab09" # Amarelo/Laranja
        elif [ "$STATUS" == "CLEAN" ]; then
           MSG="C√≥digo limpo."
           GUIDE="Nenhum literal hardcoded detectado. Nenhuma a√ß√£o de IA necess√°ria."
           COLOR="#3fb950" # Verde
        else
           MSG="Ignorado."
           GUIDE="Nenhum arquivo de c√≥digo foi alterado nesta PR."
           COLOR="#8b949e" # Cinza
        fi

        # Cria o JSON em arquivo tempor√°rio
        jq -n \
          --arg status "$STATUS" \
          --arg count "$COUNT" \
          --arg msg "$MSG" \
          --arg guide "$GUIDE" \
          --arg file "$OUT_FILE" \
          --arg color "$COLOR" \
          '{
            analysis: {
              status: $status,
              total_findings: ($count | tonumber),
              index_file: $file
            },
            ui: {
              message: $msg,
              guidance: $guide,
              color: $color
            }
          }' > /tmp/output_payload.json

        # Passa o conte√∫do do JSON para a vari√°vel de output sem heredoc
        # Usando jq -c (compact) para ser uma linha s√≥
        JSON_LINE=$(jq -c . /tmp/output_payload.json)
        echo "json_payload=$JSON_LINE" >> "$GITHUB_OUTPUT"
