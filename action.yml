# Malnati/code-literal-sentinel@v2.0.0
name: "Code Literal Sentinel"
description: "Varredura agressiva de literais. Gera um relat√≥rio e abre uma PR dedicada para an√°lise."
author: "Ricardo Malnati"

branding:
  icon: "eye"
  color: "orange"

inputs:
  token:
    description: "GitHub token (com permiss√µes de escrita) para criar Branches e PRs."
    required: true
  file_extensions:
    description: "Regex de extens√µes para varrer."
    required: false
    default: "ts|js|jsx|tsx|java|py|go|cs|php|sh|json|yaml|yml"
  exclude_patterns:
    description: "Regex de caminhos para ignorar."
    required: false
    default: "node_modules|dist|build|.git"
  report_dir:
    description: "Diret√≥rio onde os relat√≥rios ser√£o salvos."
    required: false
    default: "reports/code-literal-sentinel"

outputs:
  result_json:
    description: "JSON contendo diagn√≥stico, contagens e Link da PR de relat√≥rio."
    value: ${{ steps.generate_output.outputs.json_payload }}

runs:
  using: "composite"
  steps:
    # ------------------------------------------------------------------
    # STEP 0: DIAGN√ìSTICO
    # ------------------------------------------------------------------
    - id: debug_inputs
      shell: bash
      env:
        EXTS: ${{ inputs.file_extensions }}
        DIR: ${{ inputs.report_dir }}
      run: |
        echo "::group::üîç Step 0: Sentinel Configuration (v2.0)"
        echo "---------------------------------------------------------------"
        echo "üëÅÔ∏è  Code Literal Sentinel (Report PR Mode)"
        echo "---------------------------------------------------------------"
        echo "‚öôÔ∏è  Configura√ß√£o:"
        echo "    - Extens√µes: .($EXTS)"
        echo "    - Destino:   $DIR/<timestamp>.md"
        echo "---------------------------------------------------------------"
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 0.5: VERIFICA√á√ÉO DE ESCRITA
    # ------------------------------------------------------------------
    - id: check_perms
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
      run: |
        echo "::group::üîê Step 0.5: Permission Check (Write Access)"
        # Testa acesso de escrita na API (Dry Run de cria√ß√£o de branch simulado ou check de escopo)
        # Simplificado: Verifica se o token existe. O git push falhar√° se n√£o tiver permiss√£o.
        if [ -z "$TOKEN" ]; then
           echo "‚ùå Token n√£o fornecido."
           exit 1
        fi
        echo "‚úÖ Token presente. A valida√ß√£o final ocorrer√° no 'git push'."
        echo "   Requisito: 'contents: write' e 'pull-requests: write'."
        echo "::endgroup::"

    # ------------------------------------------------------------------
    # STEP 1: SCAN E GERA√á√ÉO DE ARQUIVO
    # ------------------------------------------------------------------
    - id: scan
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        BASE_SHA: ${{ github.event.pull_request.base.sha }}
        HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        EXTS: ${{ inputs.file_extensions }}
        EXCLUDE: ${{ inputs.exclude_patterns }}
        REPORT_DIR: ${{ inputs.report_dir }}
      run: |
        set -euo pipefail
        
        echo "üîé Iniciando varredura..."
        
        # Define nome do arquivo com timestamp
        TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
        FULL_PATH="./$REPORT_DIR/$TIMESTAMP.md"
        
        # Garante diret√≥rio
        mkdir -p "$REPORT_DIR"

        # 1. Listar arquivos
        FILES=$(git diff --name-only --diff-filter=ACMRTUXB "$BASE_SHA" "$HEAD_SHA" \
          | grep -E "\.($EXTS)$" \
          | grep -vE "$EXCLUDE" || true)

        if [ -z "$FILES" ]; then
          echo "NO_FILES" > /tmp/scan_status
          echo "0" > /tmp/scan_count
          exit 0
        fi

        # 2. Grep Agressivo
        PATTERN="\"[^\"]{2,}\"|'[^']{2,}'"
        
        # Gerar conte√∫do Markdown para o arquivo
        echo "# Relat√≥rio de Literais Hardcoded" > "$FULL_PATH"
        echo "**Data:** $TIMESTAMP" >> "$FULL_PATH"
        echo "**Origem:** SHA $HEAD_SHA" >> "$FULL_PATH"
        echo "" >> "$FULL_PATH"
        echo "## üîç Evid√™ncias Brutas" >> "$FULL_PATH"
        echo "\`\`\`text" >> "$FULL_PATH"
        echo "$FILES" | xargs -r grep -HnE "$PATTERN" >> "$FULL_PATH" || true
        echo "\`\`\`" >> "$FULL_PATH"

        # Verifica se achou algo (grep exit code ou tamanho do arquivo)
        # Contamos linhas dentro do bloco de texto (ignorando o cabe√ßalho markdown)
        COUNT=$(grep -cE "$PATTERN" "$FULL_PATH" || true)
        
        if [ "$COUNT" -gt "0" ]; then
           echo "FOUND" > /tmp/scan_status
           echo "$COUNT" > /tmp/scan_count
           echo "path=$FULL_PATH" >> "$GITHUB_OUTPUT"
        else
           echo "CLEAN" > /tmp/scan_status
           echo "0" > /tmp/scan_count
           rm "$FULL_PATH" # Limpa se vazio
        fi

    # ------------------------------------------------------------------
    # STEP 2: CRIAR BRANCH E PR DE RELAT√ìRIO
    # ------------------------------------------------------------------
    - id: create_pr
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.token }}
        REPORT_PATH: ${{ steps.scan.outputs.path }}
        HEAD_REF: ${{ github.event.pull_request.head.ref }}
        PR_NUM: ${{ github.event.pull_request.number }}
      run: |
        set -euo pipefail
        
        STATUS=$(cat /tmp/scan_status)
        PR_URL=""
        
        if [ "$STATUS" == "FOUND" ]; then
           echo "üöÄ Preparando Pull Request de Relat√≥rio..."
           
           # Config Git
           git config user.name "sentinel-bot"
           git config user.email "sentinel-bot@users.noreply.github.com"
           
           # Nome da Branch de Relat√≥rio
           TIMESTAMP=$(date +"%s")
           REPORT_BRANCH="sentinel/report-pr-${PR_NUM}-${TIMESTAMP}"
           
           # Checkout da Branch de Origem (Para derivar dela) e criar a nova
           git checkout "$HEAD_REF"
           git checkout -b "$REPORT_BRANCH"
           
           # Adicionar e Commitar o Relat√≥rio
           git add "$REPORT_PATH"
           git commit -m "docs(sentinel): add literal scan report [skip ci]"
           
           # Push
           git push origin "$REPORT_BRANCH"
           
           # Criar PR usando GH CLI
           # Base: Branch original da PR (HEAD_REF)
           # Head: Nova branch de relat√≥rio (REPORT_BRANCH)
           echo "üì° Criando PR..."
           PR_URL=$(gh pr create \
             --base "$HEAD_REF" \
             --head "$REPORT_BRANCH" \
             --title "üîç Sentinel Report: PR #$PR_NUM" \
             --body "Este √© um relat√≥rio autom√°tico gerado pelo Code Literal Sentinel. Utilize este arquivo para an√°lise assistida por IA." \
             --label "sentinel-report")
             
           echo "‚úÖ PR Criada: $PR_URL"
        fi
        
        echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 3: GERAR JSON FINAL
    # ------------------------------------------------------------------
    - id: generate_output
      shell: bash
      env:
        PR_URL: ${{ steps.create_pr.outputs.pr_url }}
      run: |
        set -euo pipefail
        
        STATUS=$(cat /tmp/scan_status)
        COUNT=$(cat /tmp/scan_count)
        
        if [ "$STATUS" == "FOUND" ]; then
           MSG="Literais detectados ($COUNT)."
           # Mensagem Rica com Link
           GUIDE="Um relat√≥rio detalhado foi gerado. **[Clique aqui para acessar a PR de An√°lise]($PR_URL)**."
           COLOR="#dbab09"
        elif [ "$STATUS" == "CLEAN" ]; then
           MSG="C√≥digo limpo."
           GUIDE="Nenhum literal hardcoded detectado."
           COLOR="#3fb950"
        else
           MSG="Ignorado."
           GUIDE="Sem altera√ß√µes em arquivos monitorados."
           COLOR="#8b949e"
        fi

        # Gera JSON
        jq -n \
          --arg status "$STATUS" \
          --arg count "$COUNT" \
          --arg msg "$MSG" \
          --arg guide "$GUIDE" \
          --arg url "$PR_URL" \
          --arg color "$COLOR" \
          '{
            analysis: {
              status: $status,
              total_findings: ($count | tonumber),
              report_pr_url: $url
            },
            ui: {
              message: $msg,
              guidance: $guide,
              color: $color
            }
          }' > /tmp/output_payload.json

        JSON_LINE=$(jq -c . /tmp/output_payload.json)
        echo "json_payload=$JSON_LINE" >> "$GITHUB_OUTPUT"
